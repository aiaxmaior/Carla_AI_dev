import pandas as pd

parameters = [
    ("mass", "m", "Vehicle mass in kg", True, True, True,
     "player.get_physics_control().mass",
     "World.py / DataIngestion.py",
     "Can be overridden via apply_physics_control()"),
    ("center_of_mass", "COM", "Center of mass offset", True, True, True,
     "player.get_physics_control().center_of_mass",
     "World.py / DataIngestion.py",
     "3D vector relative to chassis origin"),
    ("drag_coefficient", "Cd", "Air resistance coefficient", True, True, True,
     "player.get_physics_control().drag_coefficient",
     "World.py / DataIngestion.py",
     "Affects high-speed acceleration realism"),
    ("steer_angle_limit", "δ_max", "Max steering angle (deg)", True, True, True,
     "wheel.max_steer_angle from physics_control.wheels[]",
     "World.py",
     "Set individually for steerable wheels (usually index 0 and 1)"),
    ("torque_curve", "τ(RPM)", "Engine torque curve", True, True, True,
     "player.get_physics_control().torque_curve",
     "World.py",
     "Rarely overridden manually"),
    ("wheel_radius", "r", "Tire radius", True, True, True,
     "wheel.radius from physics_control.wheels[]",
     "World.py",
     "Used for velocity and angular force calculations"),
    ("lateral_stiffness", "Cα", "Tire lateral stiffness", True, True, True,
     "wheel.lateral_stiffness",
     "World.py",
     "Used in custom slip and traction modeling"),
    ("friction", "μ", "Tire-road friction coefficient", True, True, True,
     "wheel.friction",
     "World.py",
     "May vary based on surface or weather"),
    ("wheel_position", "-", "Wheel position in chassis space", True, True, True,
     "wheel.position",
     "World.py",
     "Required for calculating distances like wheelbase"),
    ("wheelbase", "L", "Distance between front and rear axles", False, False, True,
     "wheels[0].position.x - wheels[2].position.x",
     "DataIngestion.py",
     "Assumes front-left and rear-left wheels are indices 0 and 2"),
    ("track_width", "T", "Left-right wheel spacing", False, False, True,
     "wheels[0].position.y - wheels[1].position.y",
     "DataIngestion.py",
     "Front axle assumed at index 0 and 1 (FL and FR)"),
    ("vehicle_length", "ℓ", "Bumper-to-bumper length", False, False, True,
     "bounding_box.extent.x * 2",
     "DataIngestion.py",
     "Used for safety distance and visualization"),
    ("front_overhang", "-", "Front bumper to front axle", False, False, True,
     "bounding_box.extent.x - axle_x_offset",
     "DataIngestion.py",
     "Helps calculate forward collision envelope"),
    ("rear_overhang", "-", "Rear bumper to rear axle", False, False, True,
     "rear_offset = total_length - wheelbase - front_overhang",
     "DataIngestion.py",
     "Used in trailer dynamics and collision modeling"),
    ("weight_distribution", "-", "Front/rear weight ratio", False, False, True,
     "manual or measured via axle forces",
     "World.py",
     "Required for accurate yaw and roll models"),
    ("cg_height", "h", "Center of gravity height from ground", False, False, True,
     "approximated from model or bounding box",
     "Sensors.py",
     "Influences cornering, rollover risk"),
    ("tire_type", "-", "Tire type string or spec", False, False, True,
     "string from blueprint or config",
     "World.py",
     "Optional unless fine-grain tire model used"),
    ("yaw_inertia", "I_z", "Yaw moment of inertia", False, False, True,
     "approx = m*(a^2 + b^2)/12",
     "World.py",
     "Simplified box inertia calculation"),
    ("center_of_mass_estimate", "COM_est", "Estimated center of mass location", False, False, True,
     "inferred from midpoint between axles",
     "DataIngestion.py",
     "Fallback when no COM vector provided"),
    ("steer", "δ", "Steering input", True, True, False,
     "control.steer or ackermann_control.steer",
     "controls_queue.py",
     "Applies direct steering command from input"),
    ("speed", "v", "Target forward speed", True, True, False,
     "ackermann_control.speed",
     "controls_queue.py",
     "Used for velocity setting in Ackermann mode"),
    ("acceleration", "a", "Acceleration applied to vehicle", True, True, False,
     "ackermann_control.acceleration",
     "controls_queue.py",
     "Mapped from throttle or direct control"),
    ("jerk", "j", "Change rate of acceleration", True, True, False,
     "ackermann_control.jerk",
     "controls_queue.py",
     "Used to smooth transitions between accel states"),
    ("throttle", "τ_throttle", "Throttle input value", True, True, False,
     "control.throttle",
     "controls_queue.py",
     "Directly maps to propulsion force"),
    ("brake", "τ_brake", "Brake input value", True, True, False,
     "control.brake",
     "controls_queue.py",
     "Directly applies braking force"),
    ("hand_brake", "-", "Handbrake boolean flag", True, True, False,
     "control.hand_brake",
     "controls_queue.py",
     "Used for parking state or emergency stop"),
    ("reverse", "-", "Reverse gear flag", True, True, False,
     "control.reverse",
     "controls_queue.py",
     "Toggles drivetrain direction"),
    ("normalized_input", "-", "Raw joystick input [-1,1]", False, False, False,
     "pygame.event.axis(0)",
     "controls_queue.py",
     "Used as input to steering normalization pipeline"),
    ("clamped_steer", "-", "Clamped steering command", False, False, False,
     "steer_clamped = max(-1.0, min(1.0, steer))",
     "controls_queue.py",
     "Prevents oversteer or unsafe values"),
    ("vehicle_max_steer_deg", "δ_vehicle_max", "Vehicle max steering angle (deg)", False, False, False,
     "read from physics_control.wheels[i]",
     "controls_queue.py",
     "Used to map normalized to physical steering"),
    ("ackermann_target_angle", "δ_ack", "Ackermann front wheel angle", False, False, False,
     "compute from curvature, L",
     "Steering.py",
     "Used in Ackermann steering override"),
    ("turning_radius", "R", "Turning radius from steer angle", False, False, False,
     "R = L / tan(steering_angle)",
     "Steering.py",
     "Base for curvature and Ackermann mapping"),
    ("curvature", "κ(t)", "1 / turning radius", False, False, False,
     "kappa = 1 / R",
     "Steering.py",
     "Curvature of the path at time t"),
    ("slip_angle", "β", "Slip angle between velocity and heading", False, False, False,
     "beta = atan(lateral / longitudinal)",
     "DynamicMonitor.py",
     "Used to estimate loss of traction"),
    ("lateral_force", "F_y", "Lateral force from velocity and yaw", False, False, False,
     "Fy = m * v * omega",
     "DynamicMonitor.py",
     "Used in tire dynamics"),
    ("vertical_force", "F_z", "Downward force from weight", False, False, False,
     "Fz = m * g",
     "DynamicMonitor.py",
     "For slip ratio normalization"),
    ("yaw_rate", "ω", "Yaw rate (rad/s)", False, False, False,
     "from sensors or vehicle.get_transform()",
     "Sensors.py / DynamicMonitor.py",
     "Rate of change of heading"),
    ("slip_ratio", "λ", "Normalized slip vs traction", False, False, False,
     "lambda = Fy / (Cα * Fz)",
     "DynamicMonitor.py",
     "Used for stability logic"),
    ("steering_response_curve", "-", "Input remapping function", False, False, False,
     "steer_out = curve(normalized_input)",
     "Steering.py",
     "Can be speed-dependent"),
    ("inner/outer wheel angle", "-", "Ackermann adjusted per wheel", False, False, False,
     "from Ackermann logic based on radius",
     "Steering.py",
     "Used to sync front wheels"),
    ("velocity_vector", "(u, v)", "Lateral and longitudinal velocity", False, False, False,
     "u = lateral, v = longitudinal",
     "Sensors.py",
     "Used in dynamic stability"),
    ("jerk_estimate", "ĵ", "Estimated jerk from accel delta", False, False, False,
     "jerk = d(accel)/dt",
     "DynamicMonitor.py",
     "Smoothed signal for prediction or control"),
    ("beta_filtered", "β̅", "Smoothed slip angle", False, False, False,
     "filtered = exp filter or lowpass",
     "DynamicMonitor.py",
     "Used for noise-resistant control")
]
param_pd = pd.DataFrame(parameters,columns=[
    "Parameter", "Notation", "Description", "Modifiable", 
    "IS_CARLA_API_Parameter", "IsStatic", "Acquisition_Code", 
    "Source_Class", "Notes/Context"
])

print(param_pd)